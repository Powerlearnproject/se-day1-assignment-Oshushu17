[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15540307&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.
      
Software Engineering is a systematic, disciplined, quantifiable study and approach to the design, development, operation, and maintenance of a software system. The sole aim of software engineering is to develop software applications for improving quality, budget, and time efficiency.
The core tenets of software engineering includes: efficiency, reliability, maintainability and reusability. 
		            **PRINCIPLES OF SOFTWARE ENGINEERING**
1. Modularity: This involves breaking software into smaller reusable units or components called modules. Modules are capable of being tested independently. These modules exist as files.

2. Maintenance: Software must regularly be updated and this includes adding news features, mitigating security laxity and fixing bugs.

3. Abstraction: This involves concealing key implementation details of a software while exposing only the necessary functionality to other parts of the software.

4. Design: Planning the architecture and components of the software, including how different parts of the system will interact.

5. Reusability: This ensures that modules are capable of being used in multiple projects without the need of building the same modules over and over again when needed in various projects thus saving quality time and resources.

6. Encapsulation: This involves protecting the internal state of an object from external modifications by wrapping up the data and functions of an object into a single unit. Example includes having a nested function or class

7. Testing: Are means of ascertaining that software meets its requirements and is free of bugs.

8. Deployment: This involves pushing built and tested software from testing to production environment.

9 Agile Methodologies: Agile software development is an iterative and incremental approach to developing software, emphasizing flexibility, collaboration, and customer satisfaction. 
            **IMPORTANCE OF SOFTWARE ENGINEERING IN TECHNOLOGY INDUSTRY**
1. Innovation:
Software engineering is the core of innovation as it exploits creative ways of making task seamless through the use of new software tools, applications and systems. For example, the development of mobile money platforms like M-Pesa in Kenya, fosters financial inclusion by helping to  deliver financial services rural dwellers with limited or no access to traditional banking

2. Quality Assurance:
High quality, secured and bug free software ensures that codes do not break down when in use thus leading to end-user satisfaction

3. Adaptability:
Software engineering make available methodologies and tools that makes softwares adaptable to new hardware, user needs and platforms as technology continues to evolve. 

4. Reliability and Security:: 
In a world where software is used in critical systems (e.g., healthcare, finance, transportation), reliability and security are paramount. Software engineering practices ensure that software is robust and secure.

5. Collaboration and Teamwork::
Software programs like Docker, Github etc promotes collaboration among developers, testers, designers, and project managers. This teamwork is essential for large projects where many people must work together harmoniously.

6. Scalability::
This ensures that software can handle an increase in the number of user data in a given application. Software engineering ensures that software is built to scale efficiently.

7. Cost-Effectiveness::
By applying systematic and disciplined approaches, software engineering reduces the cost of software development. It helps prevent costly mistakes, rework, and inefficiencies.

Identify and describe at least three key milestones in the evolution of software engineering.

1. STRUCTURED ENGINEERING:
In the past, programming languages didn't have while loops, if statements, etc., and programmers used goto to make up the logic of their programs. This leads to an unmaintainable messy spaghetti code.
In 1960-1970s, Edsger Dijkstra, promoted the use of structured programming which introduced concepts like modularization, control structures (e.g., loops and conditionals), and subroutines/functions.
2. OBJECT ORIENTED PROGRAMMING
The advent of structured programming also gave birth to object oriented programming. In 1980s-1990s, Object-Oriented Programming (OOP) was a paradigm shift that introduced the concept of organizing software design around "objects," which are instances of classes. Each object contains data (attributes) and methods (functions) that define its behavior. OOP aimed to model software closer to real-world entities and interactions, making code more reusable, scalable, and easier to maintain. Such principles like encapsulation, polymorphism, inheritance came to the fore.
3. DevOps and Continuous Delivery (2010s):
DevOps is a cultural and technical movement that aims to bridge the gap between software development (Dev) and IT operations (Ops). DevOps has reshaped how software is developed, tested, and deployed, enabling organizations to release software updates faster and with greater confidence. It emphasizes automation, continuous integration, and continuous delivery (CI/CD) to shorten the development lifecycle and deliver software more quickly and reliably


List and briefly explain the phases of the Software Development Life Cycle.
 
1. Requirement gathering and Planning    2. Analysis      3. Design      4. Development    5. Testing   6. Implementation
(a). Requirement gathering and Planning: This phase deals with collecting data pertaining the clients requirements, project scope and setting timelines and pitching budgets
(b). Analysis: Identifying and documenting software requirements, including functional and non-functional aspects.
(c). Design: Creating a detailed design of the software architecture, user interface, and system components.
(d)  Development: This phase involves writing code, building the software, and integrating components.
(e). Testing: Verifying the software meets requirements, identifying bugs, and ensuring quality.
(f). Implementation: Deploying the software to production, configuring, and setting up the system.

Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
 
AGILE METHODOLOGIES 
1. It is a continuous iteration life cycle model to develop and test a software product.
2. It is flexible to make changes at any point of time (or at any stage of development process) .
3. There is continuous client Interaction and feedback
4. The development process is divided into sprints
5. Has short delivery time and functional software is available very quickly.

WATERFALL METHODOLOGIES
1. It is a linear sequential model to develop and test a software product.
2. Making changes after one phase is difficult and costly.
3. There is very little client involvement and very little feedback is taken.
4. The process is broken down into different phases.
5. Has long delivery time and the entire project must be completed before delivery.

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.

Software Developers are responsible for designing, coding, and implementing software applications or systems. They write clean, efficient, and maintainable code based on project requirements and design specifications. They also work closely with team members, identifying and fixing bugs in the code to ensure the software runs smoothly.

Quality Assurance Engineers identify defects and verify that the software functions as intended, ensure that software meets quality standards before getting to the end-users. To achieve softwares with quality standards, they create test plans, cases, and scripts based on the project’s requirements and specifications. Documenting defects in a bug-tracking system, prioritizing issues, and working with developers to resolve them and also making sure that new code changes don’t have a negative effect on existing functionality.

Project Engineer.: They oversee the planning, execution, and delivery of software projects. They coordinate the work of the team, manage resources, and ensure the project is completed on time, within scope, and on budget. Assigning tasks to team members and ensuring clear communication among all stakeholders. Facilitating collaboration between developers, QA engineers, designers, and other team members.

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.

**Importance of Integrated Development Environments (IDEs)**
1. Code Efficiency and Productivity: IDEs provide a rich set of features that streamline the coding process, including syntax highlighting, code completion, and real-time error detection. These features help developers write code faster and with fewer errors.
2. Debugging and Testing: Most IDEs come with integrated debugging tools that allow developers to set breakpoints, inspect variables, and step through code. This makes it easier to identify and fix bugs. Some IDEs also support running unit tests directly within the environment.
3. Project Management: IDEs often include tools for managing project files, libraries, and dependencies. This helps keep the project organized and ensures that all team members are working with the same configuration.
4. Integration With Other Tools: IDES can also be used with other software developed tools like VCS for enhanced collaboration with other developers
Examples of IDE are Visual Studio Code, PyCharm, Intelli J etc

**Importance of Version Control Systems (VCS)**
1. Collaboration: VCS allows multiple developers to work on the same codebase simultaneously. Changes made by different developers can be merged, reviewed, and managed without conflicts. This is crucial for team-based software development.
2. Branching and Merging: VCS supports branching, which allows developers to work on different features, fixes, or experiments in isolation. Once a feature is complete, it can be merged back into the main codebase. This enables parallel development and better management of different versions or releases of the software.
3. Continuous Integration and Deployment: VCS is integral to CI/CD pipelines, where code is automatically tested, built, and deployed whenever changes are committed. This leads to faster, more reliable software delivery.
Examples of VCS are Git, Subversion (SVN), and Mercurial


What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.

CHALLENGES FACED BY SOFTWARE ENGINERS
1. Staying updated can be overwhelming as new programming languages, frameworks and tools continues to emerge.
2. Debugging complex issues can be time-consuming and frustrating, especially when the root cause is difficult to identify or reproduce
3. Software engineers must balance technical considerations with business goals. Sometimes, business demands might push for faster delivery, which can conflict with the need for high-quality code.

STRATEGIC SOLUTIONS
1. Dedicating quality time to learning new skills regularly via involve taking online courses, attending workshops, and networking with tech communities can help keep abreast with the ever-evolving tech space.

2 Collaborating with peers to get a fresh perspective on the problem. Pair programming and code reviews can often lead to quicker identification of the root cause.

3. Regularly communicate with stakeholders to understand business priorities and explain the technical implications of decisions.



Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.

Unit Testing:  Involves testing individual components or "units" of the software in isolation, typically at the function or method level. The purpose is to ensure that each unit of the code performs as expected. It’s critical for early detection of issues within individual components, reducing the cost of fixing bugs later. Tools used for unit testing includes PyTest(Python), Junit (Java)

Integration Testing: This involves testing how various components  or  modules interact together, preventing integration-related bugs. It ensures that the system's components, which may function correctly individually, also work correctly when combined. Types of integration testing includes top-down, bottom-up and big bang.

System Testing: Evaluates the complete, integrated software system to verify that it meets the specified requirements. This type of testing is typically conducted in an environment that closely mirrors the production environment. It provides a thorough examination of the entire system, validating that all requirements are met.

Acceptance Testing: is the final phase of testing before the software is released to users. It is performed to determine whether the software meets the business requirements and is ready for deployment. By involving end-users in the testing process, acceptance testing builds confidence that the software will meet their needs and perform as expected.

#Part 2: Introduction to AI and Prompt Engineering
                           

Define prompt engineering and discuss its importance in interacting with AI models.

Prompt engineering is the process of designing and refining input prompts to effectively interact with AI models, like GPT.  This involves crafting prompts that are clear, specific, and aligned with the desired output, thereby optimizing the AI's performance.
The goal of prompt engineering is to elicit accurate, relevant, and contextually appropriate responses from the AI.
            
              Importance of Prompt Engineering in Interacting with AI Models
1. Clarity and Specificity: Well-crafted prompts guide the AI to focus on the most relevant information, reducing ambiguity and increasing the likelihood of accurate and useful responses.
2. Handling Complex Queries: Prompt engineering allows users to break down complex queries into manageable parts, enabling the AI to address each aspect effectively.
3. Structure and Format: Users can design prompts to obtain responses in specific formats, such as bullet points, summaries, or step-by-step instructions.
4. Diverse Perspectives: Creative prompt engineering can push the AI to explore different perspectives or generate novel ideas, making it a valuable tool for brainstorming and problem-solving.

Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.

vague prompt : write a React component
improved prompt : create a Student class component in React with id, firstName, lastName, and age as its state:
The latter is more effective as it gives clear and specfic intrsuction to the AI on the type of React component to be created and properties the state should contain
